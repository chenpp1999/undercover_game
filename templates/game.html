<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>è°æ˜¯å§åº• - æ¸¸æˆæˆ¿é—´</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.7.2/socket.io.min.js"></script>
    <style>
        :root {
            --bg-color: #f0f2f5; --container-bg: #ffffff; --primary-accent: #5e7ce2;
            --secondary-accent: #ff7c7c; --primary-text: #333333; --secondary-text: #666666;
            --border-color: #e5e7eb; --success-color: #28a745; --error-color: #dc3545;
            --warning-color: #ffc107; --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Noto Sans SC', sans-serif; background-color: var(--bg-color); min-height: 100vh; color: var(--primary-text); padding: 15px; transition: opacity 0.3s; }
        .container { max-width: 900px; margin: 0 auto; background: var(--container-bg); border-radius: 12px; padding: 25px; box-shadow: var(--shadow-lg); }

        /* --- CHANGE [2]: Header layout adjustments --- */
        .header { text-align: center; margin-bottom: 25px; position: relative; }
        .header-title-group { display: flex; align-items: center; justify-content: center; gap: 12px; }
        .header h1 { font-weight: 700; color: var(--primary-text); font-size: 1.8em; margin: 0; }
        .room-badge { background-color: var(--primary-accent); color: white; padding: 4px 10px; border-radius: 16px; font-size: 14px; font-weight: 500; }
        /* --- END CHANGE [2] --- */

        .end-game-btn { position: absolute; top: 0; right: 0; background: var(--error-color); color: white; border: none; border-radius: 6px; padding: 6px 10px; font-size: 11px; cursor: pointer; opacity: 0.9; transition: opacity 0.2s; display: none; }
        .end-game-btn:hover { opacity: 1; }

        /* --- CHANGE [3]: Room Info layout adjustments --- */
        .room-info { display: flex; justify-content: space-around; align-items: center; background-color: #f9fafb; border-radius: 8px; padding: 10px; margin-top: 20px; border: 1px solid var(--border-color); flex-wrap: wrap; }
        .info-card { text-align: center; flex: 1; padding: 5px; min-width: 80px; }
        .info-card h3 { font-size: 12px; color: var(--secondary-text); font-weight: 400; margin: 0; }
        .info-card .value { font-size: 16px; font-weight: 700; color: var(--primary-accent); }
        .info-card.info-card-full { width: 100%; flex-basis: 100%; margin-top: 10px; border-top: 1px solid var(--border-color); padding-top: 10px; }
        /* --- END CHANGE [3] --- */

        /* --- CHANGE [1]: Nickname and Word layout styles --- */
        .value-split { display: flex; justify-content: space-around; align-items: stretch; }
        .value-box { flex: 1; padding: 5px 10px; }
        .value-box:first-child { border-right: 1px solid var(--border-color); }
        .value-box h3 { font-size: 12px; color: var(--secondary-text); font-weight: 400; margin: 0; }
        .value-box .word, .value-box .value { font-size: 16px; font-weight: 700; color: var(--primary-accent); }
        #word-display-container { display: none; } /* Hide/show this container instead of the old one */
        /* --- END CHANGE [1] --- */

        .game-section { display: none; }
        .game-section.active { display: block; }
        .players-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(130px, 1fr)); gap: 15px; }
        .player-card { background-color: #f9fafb; padding: 15px; border-radius: 8px; text-align: center; border: 1px solid var(--border-color); transition: all 0.2s ease-in-out; position: relative; }
        .player-card div { font-weight: 500; margin-bottom: 5px; }
        .player-card small { font-size: 12px; color: var(--secondary-text); min-height: 18px; }
        .player-card.eliminated { opacity: 0.5; background-color: #fef2f2; border-color: var(--error-color); }
        .player-card.eliminated div { text-decoration: line-through; }
        .player-card.disconnected { border-style: dashed; border-color: #9ca3af; opacity: 0.7; }
        .player-card.disconnected::after { content: "ğŸ”Œ"; position: absolute; top: 5px; right: 5px; font-size: 12px; }
        .player-card.clickable:not(.disabled) { cursor: pointer; }
        .player-card.clickable:not(.disabled):hover { transform: translateY(-3px); box-shadow: var(--shadow); }
        .player-card.selected { border-color: var(--primary-accent); box-shadow: 0 0 0 3px rgba(94, 124, 226, 0.25); transform: translateY(-3px); }
        .player-card.disabled { cursor: not-allowed; }
        .kick-btn { position: absolute; top: -8px; right: -8px; background-color: var(--error-color); color: white; border: none; border-radius: 50%; width: 22px; height: 22px; font-size: 12px; font-weight: bold; line-height: 22px; text-align: center; cursor: pointer; opacity: 0.8; transition: opacity 0.2s, transform 0.2s; }
        .kick-btn:hover { opacity: 1; transform: scale(1.1); }
        .status-message, .speaking-order, .current-speaker-info, .speaking-finished-info, .settings-section, .tie-vote-notice { background-color: #f9fafb; border: 1px solid var(--border-color); border-radius: 8px; padding: 20px; text-align: center; margin: 25px 0; }
        .status-message h3, .speaking-order h3, .current-speaker-info h3, .speaking-finished-info h3, .settings-section h3 { margin-bottom: 10px; }
        .button { width: 100%; padding: 12px; border: none; border-radius: 8px; font-size: 16px; font-weight: 500; cursor: pointer; transition: all 0.3s; color: white; display: flex; align-items: center; justify-content: center; gap: 8px; }
        .button.primary { background-color: var(--primary-accent); }
        .button.secondary { background-color: var(--secondary-accent); }
        .button:disabled { background-color: #cccccc; cursor: not-allowed; }
        .loading-spinner { border: 2px solid rgba(255,255,255,0.3); border-top: 2px solid #fff; border-radius: 50%; width: 16px; height: 16px; animation: spin 1s linear infinite; }
        #results-section .game-results { padding: 25px; background: rgba(255, 255, 255, 0.95); backdrop-filter: blur(5px); border-radius: 12px; }
        #results-section h2 { color: var(--primary-accent); }
        #results-section .reveal-section { margin-top: 15px; }
        .player-roles { display: grid; grid-template-columns: repeat(auto-fill, minmax(130px, 1fr)); gap: 15px; margin-top: 15px; }
        .role-card { padding: 15px; border-radius: 8px; text-align: center; border: 1px solid var(--border-color); }
        .role-card.civilian { background-color: #f0fff4; }
        .role-card.undercover { background-color: #fff5f5; }
        .voter-status { font-size: 12px; color: var(--secondary-text); margin-top: 5px; }
        .voter-status.voted { color: var(--success-color); }
        .voter-status.not-voted { color: var(--error-color); }
        .vote-count-display { position: absolute; top: -10px; left: -10px; background-color: var(--secondary-accent); color: white; border-radius: 50%; width: 24px; height: 24px; font-size: 12px; font-weight: bold; display: flex; align-items: center; justify-content: center; box-shadow: var(--shadow); border: 2px solid white; }
        .back-button { position: fixed; top: 15px; left: 15px; background: rgba(255,255,255,0.8); backdrop-filter: blur(5px); border: 1px solid var(--border-color); border-radius: 50%; width: 40px; height: 40px; cursor: pointer; font-size: 18px; z-index: 1000; display:flex; align-items:center; justify-content:center; }
        .connection-status { position: fixed; bottom: 15px; right: 15px; padding: 6px 12px; border-radius: 20px; font-size: 12px; font-weight: 500; color: white; box-shadow: var(--shadow); }
        .connection-status.connected { background: var(--success-color); }
        .connection-status.disconnected { background: var(--error-color); }
        .connection-status.reconnecting { background: var(--warning-color); color: var(--primary-text); }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body>
    <button class="back-button" onclick="window.location.href='/'" title="è¿”å›å¤§å…">ğŸ </button>
    <div class="connection-status connected" id="connection-status">ğŸŸ¢ å·²è¿æ¥</div>
    <div class="container">
        <div class="header">
             <div class="header-title-group">
                <h1>ğŸ­ è°æ˜¯å§åº•</h1>
                <div class="room-badge" id="room-id-display">------</div>
            </div>
            <button id="end-game-btn" class="end-game-btn" title="ç»“æŸæ¸¸æˆ">â¹ ç»“æŸ</button>
            <div class="room-info">
                 <div class="info-card"><h3>åœ¨çº¿ç©å®¶</h3><div class="value" id="player-count">0</div></div>
                <div class="info-card"><h3>è½®æ¬¡</h3><div class="value" id="round-display">-</div></div>
                <div class="info-card"><h3>æ¸¸æˆå±€æ•°</h3><div class="value" id="game-number">1</div></div>

                 <div class="info-card info-card-full">
                    <div class="value-split">
                        <div class="value-box">
                            <h3>æˆ‘çš„æ˜µç§°</h3>
                            <div class="value" id="player-name-display">åŠ è½½ä¸­...</div>
                        </div>
                        <div class="value-box" id="word-display-container">
                             <h3 id="word-info">ä½ çš„è¯è¯­</h3>
                            <div class="word" id="my-word">---</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div id="waiting-section" class="game-section active">
            <div class="players-section"><h3>ğŸ® ç©å®¶åˆ—è¡¨</h3><div class="players-grid" id="player-list" style="margin-top: 15px;"></div></div>
            <div class="status-message" id="waiting-message">æ­£åœ¨è¿æ¥æˆ¿é—´...</div>
            <button id="settings-btn" class="button secondary" style="display: none;">âš™ï¸ æ¸¸æˆè®¾ç½®</button>
            <button id="start-btn" class="button primary" style="display: none;" disabled>ğŸš€ å¼€å§‹æ¸¸æˆ</button>
        </div>
        <div id="settings-section" class="game-section">
            <h3>âš™ï¸ æ¸¸æˆè®¾ç½®</h3>
            <div class="setting-item">
                <label for="undercover-count">å§åº•æ•°é‡</label>
                <select id="undercover-count" class="setting-item"></select>
                <small id="undercover-info" style="color: var(--secondary-text);"></small>
            </div>
            <button id="save-settings-btn" class="button primary">ğŸ’¾ ä¿å­˜è®¾ç½®</button>
            <button id="back-to-waiting-btn" class="button secondary">â† è¿”å›ç­‰å¾…</button>
        </div>
        <div id="speaking-section" class="game-section">
            <div class="players-section"><h3>ğŸ­ ç©å®¶çŠ¶æ€</h3><div class="players-grid" id="speaking-player-list" style="margin-top: 15px;"></div></div>
            <div class="speaking-order" id="speaking-order-display"><h4>ğŸ“‹ å‘è¨€é¡ºåº</h4></div>
            <div class="current-speaker-info" id="current-speaker-info"><h3>å‘è¨€é˜¶æ®µ</h3><p>è¯·æŒ‰æç¤ºé¡ºåºä¾æ¬¡å‘è¨€ã€‚</p></div>
            <div class="speaking-finished-info" id="speaking-finished-info" style="display: none;"></div>
            <button id="start-voting-btn" class="button primary" style="display: none;">ğŸ—³ï¸ å¼€å§‹æŠ•ç¥¨</button>
        </div>
        <div id="voting-section" class="game-section">
            <div id="tie-vote-notice" class="tie-vote-notice" style="display: none;"></div>
            <h3>ğŸ—³ï¸ æŠ•ç¥¨é˜¶æ®µ</h3>
            <div id="voting-instruction">è¯·é€‰æ‹©ä½ è®¤ä¸ºæ˜¯å§åº•çš„ç©å®¶å¹¶æŠ•ç¥¨</div>
            <div class="players-section" style="margin-top: 15px;"><div class="players-grid" id="voting-players"></div></div>
            <button id="submit-vote-btn" class="button secondary" disabled>ğŸ—³ï¸ ç¡®è®¤æŠ•ç¥¨</button>
        </div>
        <div id="results-section" class="game-section"></div>
    </div>
    <script>
        const socket = io(window.location.protocol + '//' + window.location.host, {
            reconnection: true,
            reconnectionDelay: 1000,
            reconnectionDelayMax: 5000,
            reconnectionAttempts: 10
        });

        let roomId, playerId, playerName, isHost = false, selectedVotePlayer = null;
        let localGameState = { status: 'waiting', eliminated: [], allPlayers: {}, disconnectedPlayers: {} };
        let hasVotedThisRound = false;

        // Centralized DOM element references
        const elements = {
            roomIdDisplay: document.getElementById('room-id-display'),
            playerNameDisplay: document.getElementById('player-name-display'),
            playerCount: document.getElementById('player-count'),
            roundDisplay: document.getElementById('round-display'),
            gameNumber: document.getElementById('game-number'),
            connectionStatus: document.getElementById('connection-status'),
            playerList: document.getElementById('player-list'),
            speakingPlayerList: document.getElementById('speaking-player-list'),
            waitingMessage: document.getElementById('waiting-message'),
            settingsBtn: document.getElementById('settings-btn'),
            startBtn: document.getElementById('start-btn'),
            endGameBtn: document.getElementById('end-game-btn'),
            undercoverCount: document.getElementById('undercover-count'),
            undercoverInfo: document.getElementById('undercover-info'),
            saveSettingsBtn: document.getElementById('save-settings-btn'),
            backToWaitingBtn: document.getElementById('back-to-waiting-btn'),

            // --- CHANGE [1]: Updated word display reference ---
            wordDisplayContainer: document.getElementById('word-display-container'),
            myWord: document.getElementById('my-word'),
            wordInfo: document.getElementById('word-info'),
            // --- END CHANGE [1] ---

            speakingOrderDisplay: document.getElementById('speaking-order-display'),
            currentSpeakerInfo: document.getElementById('current-speaker-info'),
            speakingFinishedInfo: document.getElementById('speaking-finished-info'),
            startVotingBtn: document.getElementById('start-voting-btn'),
            tieVoteNotice: document.getElementById('tie-vote-notice'),
            votingInstruction: document.getElementById('voting-instruction'),
            votingPlayers: document.getElementById('voting-players'),
            submitVoteBtn: document.getElementById('submit-vote-btn'),
            sections: {
                waiting: document.getElementById('waiting-section'),
                settings: document.getElementById('settings-section'),
                speaking: document.getElementById('speaking-section'),
                voting: document.getElementById('voting-section'),
                results: document.getElementById('results-section'),
            }
        };

        // --- REFACTORED UI RENDERING FUNCTIONS ---

        function renderVotingUI(data) {
            hasVotedThisRound = false; // Reset vote status for the new round
            localGameState.eliminated = data.eliminated_players;
            elements.votingPlayers.innerHTML = '';

            const allPlayers = data.all_players;
            const candidateIds = data.voting_candidates.map(c => c.id);
            const amIeliminated = data.eliminated_players.includes(playerId);

            Object.entries(allPlayers).forEach(([pid, player]) => {
                const card = document.createElement('div');
                card.className = 'player-card';
                card.dataset.playerId = pid;

                const isEliminated = data.eliminated_players.includes(pid);
                const isSelf = pid === playerId;
                const isCandidate = candidateIds.includes(pid);
                const isDisconnected = !Object.keys(localGameState.allPlayers).includes(pid);

                if (isDisconnected) card.classList.add('disconnected');

                if (isEliminated) {
                    card.classList.add('eliminated', 'disabled');
                    card.innerHTML = `<div>${player.name}</div><small>ğŸš« å·²æ·˜æ±°</small>`;
                } else if (isSelf) {
                    card.classList.add('disabled');
                    card.innerHTML = `<div>${player.name}</div><small>ä¸èƒ½æŠ•è‡ªå·±</small>`;
                } else if (!isCandidate && data.is_tie_vote) {
                    card.classList.add('disabled', 'eliminated');
                    card.innerHTML = `<div>${player.name}</div><small>éå€™é€‰äºº</small>`;
                } else {
                    card.classList.add('clickable');
                    card.innerHTML = `<div>${player.name}</div>`;
                    card.onclick = () => {
                        if (amIeliminated || hasVotedThisRound) return;
                        document.querySelectorAll('#voting-players .player-card.selected').forEach(el => el.classList.remove('selected'));
                        card.classList.add('selected');
                        selectedVotePlayer = pid;
                        elements.submitVoteBtn.disabled = false;
                    };
                }
                elements.votingPlayers.appendChild(card);
            });

            if (amIeliminated) {
                elements.submitVoteBtn.disabled = true;
                elements.submitVoteBtn.textContent = 'ğŸš« å·²æ·˜æ±°';
            } else {
                selectedVotePlayer = null;
                elements.submitVoteBtn.disabled = true;
                elements.submitVoteBtn.innerHTML = 'ğŸ—³ï¸ ç¡®è®¤æŠ•ç¥¨';
            }

            elements.tieVoteNotice.style.display = data.is_tie_vote ? 'block' : 'none';
            if (data.is_tie_vote) elements.tieVoteNotice.textContent = 'âš–ï¸ ä¸Šè½®æŠ•ç¥¨å¹³ç¥¨ï¼Œè¯·åœ¨ä»¥ä¸‹å€™é€‰äººä¸­é‡æ–°æŠ•ç¥¨';

            showSection('voting');
        }

        function renderResultsUI(data) {
             elements.endGameBtn.disabled = false;
             elements.endGameBtn.innerHTML = 'â¹ ç»“æŸ';
             elements.endGameBtn.style.display = 'none';

            isHost = (data.host_id === playerId);
            const gameNum = elements.gameNumber.textContent;

            let resultText = '';
            if (data.forced_end) {
                resultText = 'ğŸ›‘ æ¸¸æˆè¢«æˆ¿ä¸»æå‰ç»“æŸ';
            } else {
                resultText = data.result === 'civilians_win' ? 'ğŸ‰ å¹³æ°‘è·èƒœï¼' : 'ğŸ‰ å§åº•è·èƒœï¼';
            }

            const resultsHtml = `
                <div class="game-results">
                    <h2>ç¬¬${gameNum}å±€æ¸¸æˆç»“æŸ</h2>
                    <div class="result-details">
                        <p><strong>${resultText}</strong></p>
                        ${data.eliminated_player ? `<p>æœ€åè¢«æ·˜æ±°ï¼š<strong>${data.eliminated_player.name}</strong></p>` : ''}
                        <p>ğŸ‘¥ å¹³æ°‘è¯è¯­: <strong>${data.words.civilian}</strong></p>
                        <p>ğŸ•µï¸ å§åº•è¯è¯­: <strong>${data.words.undercover}</strong></p>
                    </div>
                </div>
                <div class="reveal-section">
                    <h4>ğŸ­ èº«ä»½æ­æ™“</h4>
                    <div class="player-roles">
                        ${data.all_players.map(p => `<div class="role-card ${p.role === 'undercover' ? 'undercover' : 'civilian'}"><div><strong>${p.name}</strong></div><div>${p.role === 'undercover' ? 'ğŸ•µï¸ å§åº•' : 'ğŸ‘¥ å¹³æ°‘'}</div></div>`).join('')}
                    </div>
                </div>
                ${data.can_continue ? `
                <div class="continue-game-section" style="margin-top:20px;">
                    <h3>ğŸ‰ å‡†å¤‡ä¸‹ä¸€å±€ï¼Ÿ</h3>
                    <button id="continue-game-btn" class="button primary" style="margin-top:10px;">${isHost ? 'ğŸ”„ å¼€å§‹æ–°æ¸¸æˆ' : 'ç­‰å¾…æˆ¿ä¸»å¼€å§‹ä¸‹ä¸€å±€'}</button>
                    <button id="view-history-btn" class="button secondary" style="margin-top:10px;">ğŸ“œ æŸ¥çœ‹å†å²è®°å½•</button>
                </div>
                <div class="history-section" style="display: none; margin-top:20px;">
                    <h4>ğŸ“Š æˆ¿é—´æ¸¸æˆå†å²</h4>
                    <div class="history-list"></div>
                    <button id="close-history-btn" class="button primary" style="margin-top:10px;">å…³é—­å†å²</button>
                </div>` : `<button onclick="window.location.href='/'" class="button primary" style="margin-top:20px;">ğŸ  è¿”å›å¤§å…</button>`}
            `;
            elements.sections.results.innerHTML = resultsHtml;

            if (data.can_continue) {
                const continueBtn = document.getElementById('continue-game-btn');
                continueBtn.disabled = !isHost;
                continueBtn.addEventListener('click', () => {
                    createButtonSpinner(continueBtn);
                    socket.emit('continue_game', { room_id: roomId });
                });
                document.getElementById('view-history-btn').addEventListener('click', () => socket.emit('get_room_history', { room_id: roomId }));
            }
            showSection('results');
        }

        // --- CORE LOGIC & SOCKET HANDLERS ---

        function showSection(sectionName) {
            Object.values(elements.sections).forEach(el => el.classList.remove('active'));
            if (elements.sections[sectionName]) {
                elements.sections[sectionName].classList.add('active');
            }

            // --- CHANGE [1]: Updated visibility logic for the new word container ---
            const shouldShowWord = ['speaking', 'voting', 'results'].includes(sectionName) && elements.myWord.textContent !== '---';
            elements.wordDisplayContainer.style.display = shouldShowWord ? 'block' : 'none';
            // --- END CHANGE [1] ---

            const showEndGameBtn = isHost && ['speaking', 'voting'].includes(sectionName);
            elements.endGameBtn.style.display = showEndGameBtn ? 'block' : 'none';
            localGameState.status = sectionName;
        }

        function showTemporaryMessage(message, type = 'info', duration = 4000) {
            // This function creates a temporary notification popup.
            const msgEl = document.createElement('div');
            const typeColors = { info: '#5e7ce2', success: '#28a745', error: '#dc3545', warning: '#ffc107' };
            msgEl.textContent = message;
            Object.assign(msgEl.style, {
                position: 'fixed', top: '20px', left: '50%', transform: 'translateX(-50%)',
                zIndex: '2000', padding: '12px 20px', borderRadius: '8px', color: 'white',
                backgroundColor: typeColors[type] || typeColors.info,
                boxShadow: '0 5px 15px rgba(0,0,0,0.2)',
                fontSize: '14px',
                fontWeight: '500',
                textAlign: 'center'
            });
            document.body.appendChild(msgEl);
            setTimeout(() => {
                msgEl.style.transition = 'opacity 0.5s';
                msgEl.style.opacity = '0';
                setTimeout(() => msgEl.remove(), 500);
            }, duration);
        }

        function updatePlayerGrid(container, allPlayers, disconnectedPlayers = {}, eliminatedIds = [], hostId = '') {
            container.innerHTML = '';
            const combinedPlayers = { ...allPlayers, ...disconnectedPlayers };

            // Ensure consistent order if possible
            const playerIdsInOrder = Object.keys(combinedPlayers);

            playerIdsInOrder.forEach(pid => {
                const player = combinedPlayers[pid];
                const playerCard = document.createElement('div');
                let cardClass = 'player-card';
                const isDisconnected = !allPlayers[pid];
                const isEliminated = eliminatedIds.includes(pid);

                if (isEliminated) cardClass += ' eliminated';
                if (isDisconnected) cardClass += ' disconnected';
                playerCard.className = cardClass;
                playerCard.dataset.playerId = pid;

                let innerHTML = `<div>${player.name}</div>`;
                if (pid === hostId) innerHTML += `<small>ğŸ‘‘ æˆ¿ä¸»</small>`;
                else if (isEliminated) innerHTML += `<small>ğŸš« å·²æ·˜æ±°</small>`;
                else if (isDisconnected) innerHTML += `<small>ğŸ”Œ æ‰çº¿ä¸­</small>`;
                else innerHTML += `<small>&nbsp;</small>`; // for alignment
                playerCard.innerHTML = innerHTML;

                if (isHost && pid !== playerId && localGameState.status === 'waiting' && !isEliminated) {
                    const kickBtn = document.createElement('button');
                    kickBtn.textContent = 'Ã—';
                    kickBtn.title = `å°† ${player.name} è¸¢å‡ºæˆ¿é—´`;
                    kickBtn.className = 'kick-btn';
                    kickBtn.onclick = (e) => {
                        e.stopPropagation();
                        if (confirm(`ç¡®å®šè¦å°†ç©å®¶ ${player.name} ç§»å‡ºæˆ¿é—´å—ï¼Ÿ`)) {
                            socket.emit('kick_player', { room_id: roomId, player_id_to_kick: pid });
                        }
                    };
                    playerCard.appendChild(kickBtn);
                }
                container.appendChild(playerCard);
            });
        }

        function updatePlayerList(data) {
            const oldHost = isHost;
            isHost = (data.host_id === playerId);

            const onlinePlayers = data.players || {};
            const disconnectedPlayers = data.disconnected_players || {};

            localGameState.allPlayers = onlinePlayers;
            localGameState.disconnectedPlayers = disconnectedPlayers;

            const onlineCount = Object.keys(onlinePlayers).length;
            const totalCount = onlineCount + Object.keys(disconnectedPlayers).length;

            elements.playerCount.textContent = `${onlineCount}/${totalCount}`;
            updatePlayerGrid(elements.playerList, onlinePlayers, disconnectedPlayers, [], data.host_id);

            if (oldHost !== isHost) {
                showTemporaryMessage(isHost ? 'æ‚¨å·²æˆä¸ºæˆ¿ä¸»ï¼' : 'æˆ¿ä¸»å·²æ›´æ¢', 'info');
                // Re-render current section to update host-specific controls
                showSection(localGameState.status);
            }

            if (localGameState.status === 'waiting') {
                elements.settingsBtn.style.display = isHost ? 'flex' : 'none';
                elements.startBtn.style.display = isHost ? 'flex' : 'none';
                if (isHost) {
                    elements.startBtn.disabled = onlineCount < 3;
                    elements.waitingMessage.textContent = onlineCount >= 3 ? 'å‡†å¤‡å°±ç»ªï¼æˆ¿ä¸»å¯ä»¥å¼€å§‹æ¸¸æˆ' : `ç­‰å¾…æ›´å¤šåœ¨çº¿ç©å®¶... (è¿˜éœ€ ${3 - onlineCount} äºº)`;
                } else {
                    elements.waitingMessage.textContent = 'ç­‰å¾…æˆ¿ä¸»å¼€å§‹æ¸¸æˆ...';
                }
            }
            updateUndercoverOptions(totalCount);
        }

        function updateUndercoverOptions(playerCount) {
            const select = elements.undercoverCount;
            const current = select.value;
            select.innerHTML = '';
            const max = Math.max(1, Math.floor((playerCount - 1) / 2));
            elements.undercoverInfo.textContent = `å¯¹äº ${playerCount} åç©å®¶ï¼Œæœ€å¤šå¯è®¾ç½® ${max} ä¸ªå§åº•ã€‚`;
            for (let i = 1; i <= max; i++) {
                const option = new Option(`${i}ä¸ªå§åº•`, i);
                select.add(option);
            }
            select.value = (current && current <= max) ? current : '1';
        }

        let heartbeatInterval;
        let heartbeatTimeout;

        function startHeartbeat() {
            clearInterval(heartbeatInterval);
            clearTimeout(heartbeatTimeout);
            heartbeatInterval = setInterval(() => {
                socket.emit('ping');
                heartbeatTimeout = setTimeout(() => {
                    elements.connectionStatus.className = 'connection-status disconnected';
                    elements.connectionStatus.textContent = 'ğŸ”´ è¿æ¥è¶…æ—¶';
                }, 10000);
            }, 25000);
        }

        socket.on('pong', () => clearTimeout(heartbeatTimeout));

        socket.on('connect', () => {
            document.body.style.opacity = '1';
            elements.connectionStatus.className = 'connection-status connected';
            elements.connectionStatus.textContent = 'ğŸŸ¢ å·²è¿æ¥';
            if (roomId && playerId && playerName) {
                showTemporaryMessage('è¿æ¥æ¢å¤ï¼Œæ­£åœ¨é‡æ–°åŠ å…¥æˆ¿é—´...', 'success');
                socket.emit('join_room', { room_id: roomId, player_name: playerName, player_id: playerId });
            }
            startHeartbeat();
        });

        socket.on('joined_successfully', (data) => {
            playerId = data.player_id;
            sessionStorage.setItem('player_id', playerId);
        });

        socket.on('disconnect', () => {
            document.body.style.opacity = '0.7';
            elements.connectionStatus.className = 'connection-status disconnected';
            elements.connectionStatus.textContent = 'ğŸ”´ è¿æ¥æ–­å¼€';
            showTemporaryMessage('è¿æ¥å·²æ–­å¼€ï¼Œæ­£åœ¨å°è¯•é‡è¿...', 'error', 10000);
            clearInterval(heartbeatInterval);
            clearTimeout(heartbeatTimeout);
        });

        socket.on('player_list_update', updatePlayerList);
        socket.on('settings_updated', data => { elements.undercoverCount.value = data.undercover_count; showTemporaryMessage('æ¸¸æˆè®¾ç½®å·²æ›´æ–°', 'success'); });
        socket.on('you_were_kicked', (data) => { alert(data.message || 'æ‚¨å·²è¢«æˆ¿ä¸»ç§»å‡ºæˆ¿é—´ã€‚'); window.location.href = '/'; });

        socket.on('game_started', data => {
            localGameState.eliminated = [];
            elements.myWord.textContent = data.word || '---';
            elements.gameNumber.textContent = data.game_number;
            elements.roundDisplay.textContent = data.round;
            elements.wordInfo.textContent = `ç¬¬ ${data.round} è½® - ä½ çš„è¯è¯­`;
        });

        socket.on('speaking_phase', data => {
            isHost = (data.host_id === playerId);
            localGameState.eliminated = data.eliminated_players || [];
            if(data.all_players) {
                localGameState.allPlayers = data.all_players;
            }

            elements.roundDisplay.textContent = data.round;
            elements.wordInfo.textContent = `ç¬¬ ${data.round} è½® - ä½ çš„è¯è¯­`;
            if (data.just_eliminated) {
                showTemporaryMessage(`${data.just_eliminated.name} è¢«æ·˜æ±°äº†!`, 'warning');
            }

            updatePlayerGrid(elements.speakingPlayerList, localGameState.allPlayers, localGameState.disconnectedPlayers, data.eliminated_players, data.host_id);

            const firstSpeaker = data.speaking_order.length > 0 ? data.speaking_order[0].name : 'ç©å®¶';
            const directionText = data.speaking_direction || 'é¡ºæ—¶é’ˆ';
            elements.speakingOrderDisplay.innerHTML = `<h4>ğŸ“‹ å‘è¨€é¡ºåº (${directionText})</h4><p>è¯·ä» <strong>${firstSpeaker}</strong> å¼€å§‹å‘è¨€ï¼Œå…¨éƒ¨å‘è¨€ç»“æŸåæˆ¿ä¸»å¯å¼€å§‹æŠ•ç¥¨ã€‚</p>`;
            elements.currentSpeakerInfo.style.display = 'block';
            elements.startVotingBtn.style.display = 'none';
            showSection('speaking');
        });

        socket.on('all_speakers_finished', () => {
            elements.currentSpeakerInfo.style.display = 'none';
            if (isHost) {
                elements.startVotingBtn.style.display = 'flex';
                elements.startVotingBtn.disabled = false;
                elements.startVotingBtn.innerHTML = 'ğŸ—³ï¸ å¼€å§‹æŠ•ç¥¨';
                elements.startVotingBtn.onclick = () => {
                     createButtonSpinner(elements.startVotingBtn);
                     socket.emit('force_start_vote', { room_id: roomId });
                };
            }
        });

        socket.on('voting_phase', renderVotingUI);

        socket.on('vote_results_update', data => {
            const votes = data.votes || {};
            document.querySelectorAll('.vote-count-display').forEach(el => el.remove());
            document.querySelectorAll('#voting-players .player-card').forEach(card => {
                const pid = card.dataset.playerId;
                const voteCount = votes[pid] || 0;
                if (voteCount > 0) {
                    const voteCountEl = document.createElement('div');
                    voteCountEl.className = 'vote-count-display';
                    voteCountEl.textContent = voteCount;
                    card.appendChild(voteCountEl);
                }
            });
        });

        socket.on('vote_status_update', data => {
            document.querySelectorAll('#voting-players .player-card').forEach(card => {
                const pid = card.dataset.playerId;
                let statusEl = card.querySelector('.voter-status');
                if (!statusEl) {
                    statusEl = document.createElement('div');
                    statusEl.className = 'voter-status';
                    card.appendChild(statusEl);
                }
                if (data.voted_players.includes(pid)) {
                    statusEl.textContent = 'âœ… å·²æŠ•ç¥¨';
                    statusEl.className = 'voter-status voted';
                } else if (!localGameState.eliminated.includes(pid)) {
                     statusEl.textContent = 'â³ ç­‰å¾…æŠ•ç¥¨';
                     statusEl.className = 'voter-status not-voted';
                } else {
                    statusEl.textContent = '';
                }
            });
        });

        socket.on('tie_vote', data => showTemporaryMessage(data.tied_players.length > 0 ? `æŠ•ç¥¨å¹³ç¥¨ï¼å¹³ç¥¨ç©å®¶ï¼š${data.tied_players.map(p=>p.name).join('ã€ ')}ã€‚å³å°†å¼€å§‹é‡æ–°æŠ•ç¥¨...` : `æ— äººæŠ•ç¥¨ï¼Œæœ¬è½®æµç¥¨ã€‚`, 'warning', 5000));

        socket.on('game_finished', renderResultsUI);

        socket.on('sync_state', (data) => {
            showTemporaryMessage('æ¸¸æˆçŠ¶æ€å·²åŒæ­¥ï¼', 'success');
            isHost = (data.host_id === playerId);
            localGameState = { ...localGameState, ...data };

            elements.myWord.textContent = data.my_word || '---';
            elements.gameNumber.textContent = data.game_number;
            elements.roundDisplay.textContent = data.round;
            elements.wordInfo.textContent = `ç¬¬ ${data.round || 1} è½® - ä½ çš„è¯è¯­`;

            updatePlayerList({
                players: data.all_players || {},
                disconnected_players: data.disconnected_players || {},
                host_id: data.host_id
            });

            if (data.status === 'finished' && data.last_game_result) {
                renderResultsUI(data.last_game_result);
            } else if (data.status === 'speaking') {
                socket.emit('speaking_phase', data);
            } else if (data.status === 'voting') {
                renderVotingUI(data);
            } else {
                showSection(data.status);
            }
        });

        socket.on('room_history', data => {
            const historyContainer = document.querySelector('.history-section');
            const historyList = historyContainer.querySelector('.history-list');
            historyList.innerHTML = data.history.length === 0 ? '<div style="text-align:center;color:#666;padding:10px;">æš‚æ— æ¸¸æˆå†å²è®°å½•</div>'
                : data.history.reverse().map(game => `<div style="border-bottom:1px solid #eee;padding:8px 4px;">
                        <div><strong>ç¬¬${game.game_number}å±€</strong></div>
                        <div style="font-size:12px;color:#666;">å¹³æ°‘: ${game.words.civilian} | å§åº•: ${game.words.undercover}</div>
                    </div>`).join('');
            historyContainer.style.display = 'block';
            document.getElementById('view-history-btn').style.display = 'none';
            document.getElementById('continue-game-btn').style.display = 'none';
            document.getElementById('close-history-btn').onclick = () => {
                historyContainer.style.display = 'none';
                document.getElementById('view-history-btn').style.display = 'flex';
                document.getElementById('continue-game-btn').style.display = 'flex';
            };
        });

        socket.on('host_transferred', data => {
            isHost = (data.new_host_id === playerId);
            showTemporaryMessage(isHost ? `æ‚¨å·²æˆä¸ºæ–°æˆ¿ä¸»ï¼` : `æˆ¿ä¸»å·²è½¬ç§»ç»™ ${data.new_host_name}`, 'success');

            updatePlayerList({
                players: localGameState.allPlayers,
                disconnected_players: localGameState.disconnectedPlayers || {},
                host_id: data.new_host_id
            });

            if (localGameState.status === 'finished') {
                const continueBtn = document.getElementById('continue-game-btn');
                if (continueBtn) {
                    continueBtn.disabled = !isHost;
                    continueBtn.textContent = isHost ? 'ğŸ”„ å¼€å§‹æ–°æ¸¸æˆ' : 'ç­‰å¾…æˆ¿ä¸»å¼€å§‹ä¸‹ä¸€å±€';
                }
            } else if (localGameState.status === 'speaking') {
                socket.emit('all_speakers_finished', {});
            } else {
                 showSection(localGameState.status);
            }
        });

        function resetAllButtons() {
            ['start-btn', 'start-voting-btn', 'submit-vote-btn', 'continue-game-btn', 'end-game-btn', 'save-settings-btn'].forEach(id => {
                const btn = document.getElementById(id);
                if (btn && btn.disabled) {
                    btn.disabled = false;
                    if(id === 'start-btn') btn.innerHTML = 'ğŸš€ å¼€å§‹æ¸¸æˆ';
                    if(id === 'start-voting-btn') btn.innerHTML = 'ğŸ—³ï¸ å¼€å§‹æŠ•ç¥¨';
                    if(id === 'submit-vote-btn') btn.innerHTML = 'ğŸ—³ï¸ ç¡®è®¤æŠ•ç¥¨';
                    if(id === 'continue-game-btn' && isHost) btn.innerHTML = 'ğŸ”„ å¼€å§‹æ–°æ¸¸æˆ';
                    if(id === 'end-game-btn') btn.innerHTML = 'â¹ ç»“æŸ';
                    if(id === 'save-settings-btn') btn.innerHTML = 'ğŸ’¾ ä¿å­˜è®¾ç½®';
                }
            });
        }

        socket.on('error', data => {
            showTemporaryMessage(data.message || 'å‘ç”Ÿé”™è¯¯', 'error');
            resetAllButtons();
        });

        function createButtonSpinner(button) {
            button.disabled = true;
            button.innerHTML = `<div class="loading-spinner"></div>`;
        }

        window.addEventListener('load', () => {
            roomId = sessionStorage.getItem('room_id');
            playerId = sessionStorage.getItem('player_id');
            playerName = sessionStorage.getItem('player_name');
            if (!roomId || !playerName) {
                alert('æ¸¸æˆä¿¡æ¯ä¸¢å¤±ï¼Œå°†è¿”å›å¤§å…');
                return window.location.href = '/';
            }
            elements.roomIdDisplay.textContent = roomId;
            elements.playerNameDisplay.textContent = playerName;
        });

        elements.settingsBtn.addEventListener('click', () => showSection('settings'));
        elements.backToWaitingBtn.addEventListener('click', () => showSection('waiting'));
        elements.saveSettingsBtn.addEventListener('click', () => {
            socket.emit('update_settings', { room_id: roomId, undercover_count: parseInt(elements.undercoverCount.value) });
            showSection('waiting');
        });
        elements.startBtn.addEventListener('click', () => {
            createButtonSpinner(elements.startBtn);
            socket.emit('start_game', { room_id: roomId });
        });

        elements.submitVoteBtn.addEventListener('click', () => {
            if (selectedVotePlayer && !hasVotedThisRound) {
                hasVotedThisRound = true;
                createButtonSpinner(elements.submitVoteBtn);
                socket.emit('submit_vote', { room_id: roomId, voted_player_id: selectedVotePlayer });

                const allKnownPlayers = { ...localGameState.allPlayers, ...localGameState.disconnectedPlayers };
                const votedPlayerName = allKnownPlayers[selectedVotePlayer]?.name || 'æœªçŸ¥ç©å®¶';
                elements.submitVoteBtn.textContent = `âœ… å·²æŠ• ${votedPlayerName}`;
            }
        });
        elements.endGameBtn.addEventListener('click', () => {
            if (confirm('ç¡®å®šè¦ç»“æŸå½“å‰æ¸¸æˆå—ï¼Ÿ\næ¸¸æˆå°†ç«‹å³ç»“æŸå¹¶æ˜¾ç¤ºç»“æœé¡µé¢ã€‚')) {
                createButtonSpinner(elements.endGameBtn);
                socket.emit('end_game', { room_id: roomId });
            }
        });
    </script>
</body>
</html>